%{
#include <assert.h>
#include <iostream>
#include <stdlib.h>
#include <string>
#include <stdio.h>
#include <vector>

#include "llvm/IR/Instruction.h"
#include "llvm/IR/Instructions.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/IR/Value.h"

/** ================== Tree ==================== **/

class Node; // forward declaration
typedef Node *NODEPTR;

struct burm_state;
typedef burm_state *StatePtr;

class Node {
	unsigned _op;
	StatePtr _state;  
	const llvm::Value *_value;
	int _num_kids;
	Node **_kids;
public:
	Node (unsigned op, std::vector<Node *> *kids, const llvm::Value *value) 
		: _op(op),
			_state(0),
			_value(value) {
		if ((kids == NULL) || (kids->size() == 0)) {
			_num_kids = 0;
			_kids = NULL;
		}
		else {
			_num_kids = kids->size();
			_kids = new NODEPTR[_num_kids];
			for (int i = 0; i < _num_kids; ++i) 
				_kids[i]=(*kids)[i];
		}
	}
	~Node(){
		delete _kids;
	}
	unsigned getOp() {
		return _op;
	}
	void setOp(int op) {
		_op = op;
	}
	StatePtr getState() {
		return _state;
	}
	void setState(StatePtr state) {
		_state = state;
	}
	const llvm::Value* getValue() {
		return _value;
	}
	int getNumKids() {
		return _num_kids;
	}
	NODEPTR *getKids() {
		return _kids;
	}
};

#define GET_KIDS(p)	((p)->getKids())
#define PANIC printf
#define STATE_LABEL(p) ((p)->getState())
#define SET_STATE(p,s) ((p)->setState(s))
#define DEFAULT_COST	break
#define NO_ACTION(x)

/** ================= Cost =================== **/

class COST {
  int _cost;
public:
	COST(int cost) {
		_cost = cost;
	}
	int getCost() {
		return _cost;
	}
	void setCost(int cost) {
		_cost = cost;
	}
};

#define COST_LESS(a,b) ((a).getCost() < (b).getCost())

static COST COST_INFINITY = COST(32767);
static COST COST_ZERO     = COST(0);

/** ================ Operations ================ **/
enum {
  BINARY_OP=0,    //Binary operation
  CONST=1,        //Constant
  ADD=2,          //Addition
  MOV=3,          //Move
  ADDR=4,         //Address
  STORE=5
};

/** =========================================== **/

class CodeGenerator {
public:
  static void generateCode(NODEPTR p);
};

int OP_LABEL(NODEPTR node);
void burm_trace(NODEPTR node, int eRuleNo, COST cost);

//You need to pass in the necessary info (e.g. registers, memory locations)
// to the action call when you call it to generate code
%}
%term CONST=1 BINARY_OP=0 ADD=2 MOV=3 ADDR=4
%term STORE=5
%declare<void> stmt<int indent>;
%declare<void> rc<int indent>;
%declare<void> mem<int indent>;
%declare<void> const<int indent>;
%%

stmt: ADD(mem, rc)
      { $cost[0].setCost($cost[2].getCost()+$cost[3].getCost()); }
      = { 
        std::string realIndent = "";
        for (int i=0; i<indent; i++) realIndent += "  "; 
        std::cout << realIndent << "Add operation\n";
        $action[2](indent+1);
        $action[3](indent+1);
      };

stmt: MOV(mem, rc)
      { $cost[0].setCost($cost[2].getCost()+$cost[3].getCost()); }
      = { 
        std::string realIndent = "";
        for (int i=0; i<indent; i++) realIndent += "  "; 
        std::cout << realIndent << "Move operation\n";
        $action[2](indent+1);
        $action[3](indent+1);
      };

rc: mem
    { $cost[0].setCost($cost[1].getCost()); }
    = {
      std::string realIndent = "";
      for (int i=0; i<indent; i++) realIndent += "  "; 
      std::cout << realIndent << "rc can be a mem\n";
      $action[1](indent+1);
    };

rc: const
    { $cost[0].setCost($cost[1].getCost()); }
    = {
      std::string realIndent = "";
      for (int i=0; i<indent; i++) realIndent += "  "; 
      std::cout << realIndent << "rc can be a const\n";
      $action[1](indent+1);
    };

mem: ADDR
    { $cost[0].setCost(1); }
    = {
      std::string realIndent = "";
      for (int i=0; i<indent; i++) realIndent += "  "; 
      std::cout << realIndent << "Register or Memory\n";
    };

const: CONST
       { $cost[0].setCost(1); }
       = {
         std::string realIndent = "";
         for (int i=0; i<indent; i++) realIndent += "  "; 
         std::cout << realIndent << "Constant\n";
       };
%%

//The action can be anything; in this case, it is to generate assembly code.
//The action we have to write, from what I think you are implying,
// can/should do register allocation as well as code generation.

void CodeGenerator::generateCode(NODEPTR p) {
	if (p != nullptr && burm_label(p) == 0)
		std::cerr << "No match found for the node provided.\n";
	else if (p != nullptr) {
		stmt_action(p->getState(),1);
	}
}

int OP_LABEL(NODEPTR node) {
  switch (node->getOp()) {
    case CONST:  if (node->getValue() == 0) return 661 /* I0I */;
    default:     return node->getOp();
  }
}

void burm_trace(NODEPTR node, int eRuleNo, COST cost){
}


